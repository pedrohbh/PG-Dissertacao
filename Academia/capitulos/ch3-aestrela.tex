% ==============================================================================
% TCC - Nome do Aluno
% Capítulo 3 - Especificação de Requisitos
% ==============================================================================
\chapter{Algoritmo A*}
\label{sec-aestrela}

\section{O Algoritmo}
\label{sec-aestrela-algoritmo}
O algoritmo A* (lê-se "A estrela") também conhecido como busca A* é um algoritmo de busca informatizada em grafos. Foi proposta originalmente em (buscar referência) e pode ser visto como uma adaptação do algoritmo de Dijkstra (apresentado no capítulo \ref{sec-dijkstra}) em que, ao invés de se calcular a melhor rota de um ponto de partida para todos os demais vértices do grafo, se estabelece uma boa rota (ou mesmo a rota ótima\footnote{A garantia do valor ótimo do algoritmo depende de fatores que serão discutidos na subseção \ref{sec-aestrela-algoritmo-heuristica}.}) partindo do vértice origem a um vértice destino. Isso é feito realizando "podas" do caminho de forma que não seja necessário visitar todos os vértices, apenas os mais promissores.

A seguir é apresentado o algoritmo A* adaptado de \citeonline{likhachev2008anytime} sobre o algoritmo de Dijkstra apresentado na seção \ref{sec-dijkstra-algoritmo}. 

\begin{lstlisting}[ mathescape, label=lst-aestrela-codigo, caption=Algoritmo A*, float=htpb]
$A^{*}$Algorithm(weighted simple digraph, vertex first, vertex goal)
	for all vertices v
		g(v) = $\infty$;
	g(first) = 0;
	toBeChecked = all vertices;
	while goal is in toBeChecked
		v = a vertex in toBeChecked with minimal f(v);
		remove v from toBeChecked;
		for all vertices u adjacent to v and in toBeChecked
			if g( u ) > g( v ) + weight( edge(vu) )
				g( u ) = g( v ) + weight( edge(vu) );
				predecessor( u ) = v;
				update u in toBeChecked with f(u) = g(u) + h(u);
\end{lstlisting}

O algoritmo segue em sua essência como um Dijkstra adaptado. Iniciamos a distância de todos os vértices g(v) como sendo $\infty$\footnote{Vide nota de rodapé da seção \ref{sec-dijkstra-algoritmo}.} (o valor de g(v) corresponde ao valor da distância calculada do vértice origem "first" até o vértice "v") com exceção do vértice origem, cujo valor atribuído é zero. Adicionamos todos os vértices ao grupo dos "toBeChecked" \footnote{Algumas literaturas designam esse conjunto como OPEN.}. Feito isso inicia-se o processo iterativo: enquanto o vértice "goal" estiver dentro do conjunto do "toBeChecked" (ou seja, o vértice "goal" não foi alcançado ainda pelo algoritmo), o vértice com menor valor f(v) é retirado do conjunto "toBeChecked" e para cada vértice adjacente u de v, verifica-se se o valor de g( u ) atual é maior que g( v ) mais o peso da aresta entre v e u (edge(vu)). Se caso for verdade, o valor de g( u ) é atualizado para g( v ) mais o peso da aresta entre v e u, e v é marcado como o predecessor de u. O valor do peso do vértice u é atualizado na fila de prioridades utilizada (como a heap binária, descrita na subseção \ref{sec-dijkstra-versoes-heap}) com o valor f( u ) = g( u ) + h( u ).

Observe que para o algoritmo A*, diferente do que ocorre em Dijkstra, não utiliza o valor de g( u ) (valor da distância calculada do vértice origem "first" até o vértice "u") como chave de ordenamento da fila de prioridade, mas sim esse valor acrescido de h( u ). Observe também que o algoritmo para ao ser removido o vértice destino ("goal") da lista do "toBeChecked" em contrapartida ao Dijkstra que calcula para todos os vértices do grafo.

O termo h( u ) significa o valor heurístico que corresponde a uma estimativa da distância de u ao vértice destino "goal". É devido a esse valor que o algoritmo A* realiza "podas" no número de vértices a serem checados, buscando os mais promissores, já que o valor heurístico faz com que os vértices cujas estimativas sejam mais próximas do vértice destino ("goal") sejam colocados mais a frente na fila de prioridades e por consequência, sejam calculadas primeiros. E assim é mais provável que o vértice destino seja alcançado antes e tenha sua rota calculada, terminando o algoritmo. O valor h( u ) é classificado como admissível e não-admissível cujo significado será dado na subseção \ref{sec-aestrela-algoritmo-heuristica}.

A figura \ref{fig-aestrela-algoritmo-mapa1} contida em \citeonline{russell1995modern} mostra um exemplo de aplicação do algoritmo.

\begin{figure}[H]
\centering
\includegraphics[width=.90\textwidth]{figuras/Aestrela-mapa1} 
\caption{Mapa da Romênia com os valores das distâncias entre as cidades, e a distância euclidiana até Bucareste.}
\label{fig-aestrela-algoritmo-mapa1}
\end{figure}

Um viajante deseja partir da cidade de Arad com destino a Bucareste buscando percorrer o menor caminho entre essas duas cidades. Para isso é utilizado o algoritmo A* que explora o grafos conforme descrito na figura \ref{fig-aestrela-algoritmo-mapa2}, tendo como heurística utilizada, a distância euclidiana entre todas as cidades e Bucareste (distâncias também contida na figura \ref{fig-aestrela-algoritmo-mapa1}).

\begin{figure}[H]
\centering
\includegraphics[width=.90\textwidth]{figuras/Aestrela-mapa2} 
\caption{Desenvolvimento do algoritmo A*.}
\label{fig-aestrela-algoritmo-mapa2}
\end{figure}




%\citeonline{russell1995modern,cormen2009introduction}.

%\begin{lstlisting}[ mathescape, label=lst-aestrela-codigo, caption=Algoritmo A*, float=htpb]
%Entrada: Grafo G, vértice inicial $v_{i}$, vértice destino $v_{f}$
%	para todo vértice $s \in V(G), s \neq vi$ faça
%		$g(s) = \infty$
%	fim para
%	$g(v_{i}) = 0$
%	para todo vértice $s \in V(G)$ faça
%		anterior($s$) = -1
%	fimpara
%	OPEN = {$v_{i}$}
%	enquanto $v_{f}$ não é expandido faça
%		s = desenfila(OPEN)
%		para cada sucessor $s'$ de $s$ faça
%			se $g(s') > g(s) + c(s,s')$ então
%				$g(s') = g(s) + c(s,s')$
%				anterior($s'$) = s
%				insira/atualize $s'$ em OPEN pelo valor de f
%			fim se
%		fim para
%	fim enquanto
%retorna anterior
%\end{lstlisting}



\subsection{Heurísticas admissíveis e não-admissíveis}
\label{sec-aestrela-algoritmo-heuristica}  
O fator heurístico h( u ) é uma estimativa da distância entre o vértice "u" e o vértice "goal". Ela é chamada de \textbf{admissível} quando o valor da estimativa garantidamente não superestima o valor da distância real entre "u" e "goal" \cite{russell1995modern}. Um exemplo clássico usado de heurística admissível é a distância euclidiana, já que a menor distância entre dois pontos é uma reta \cite{russell1995modern}.

O cálculo da distância euclidiana porém, nem sempre é a forma mais rápida em termos computacionais, já que geralmente ela é calculada em termos dos pontos geográficos do vértice e esse cálculo envolve exponenciação e radiação. É por isso que existe o uso de heurísticas \textbf{não-admissíveis}, que são estimativas que visam a usar cálculos mais simples, porém não há a garantia que essa distância superestime a distância real entre "u" e "goal", e com isso não há garantia que o melhor caminho seja encontrado.

Exemplos de heurísticas não-admissíveis:
\begin{itemize}
\item Distância Manhattan: h( u ) = $| x_{u} - x_{goal} | + | y_{u} - y_{goal}|$;
\item Atalho Diagonal: h( u ) = $\sqrt{2} * | y_{u} - y_{goal}| + ( | x_{u} - x_{goal} | - | y_{u} - y_{goal}| )$ [Se a distância $| x_{u} - x_{goal} | > | y_{u} - y_{goal}|$] || $\sqrt{2} * | x_{u} - x_{goal}| + ( | y_{u} - y_{goal}| - | x_{u} - x_{goal} | )$ [Se a distância $| x_{u} - x_{goal} | < | y_{u} - y_{goal}|$];
\end{itemize}

\section{Experimentos Computacionais}
\label{sec-aestrela-experimentos}

Para os experimentos computacionais serão utilizados as mesmas instâncias descritas em subseção \ref{sec-dijkstra-experimentos}. Serão comparados quatro versões de algoritmos: o algoritmo de Dijkstra descrito no capítulo \ref{sec-dijkstra}, o algoritmo de Dijkstra adaptado onde o algoritmo é parado assim que se é explorado o vértice objetivo, o algoritmo A* onde se utiliza a heurística admissível distância euclidiana e o algoritmo A* onde se utiliza a heurística não-admissível distância Manhattan, todas sumarizadas na tabela X.
