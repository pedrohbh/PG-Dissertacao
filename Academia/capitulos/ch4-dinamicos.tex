% ==============================================================================
% TCC - Nome do Aluno
% Capítulo 3 - Projeto Arquitetural e Implementação
% ==============================================================================
\chapter{Algoritmos Dinâmicos}
\label{sec-dinamicos}

\section{Grafos Dinâmicos}
\label{sec-dinamicos-grafos}


\section{Algoritmo ARA*}
\label{sec-dinamicos-ara}

O algoritmo ARA* proposto em \citeonline{likhachev2008anytime}, está descrito nas listagens \ref{lst-dinamicos-ara-computepath}, \ref{lst-dinamicos-ara-key} e \ref{lst-dinamicos-ara-main}.

\begin{lstlisting}[mathescape, label=lst-dinamicos-ara-computepath, caption=Algoritmo ARA* - função de cálculo de caminho, float=htpb]
procedure ComputePath()
	while(key($s_{goal}$) > $min_{s \in OPEN(key(s))}$)
		remove s with smallest key(s) from OPEN;
		v(s) = g(s); CLOSED = CLOSED $\cup$ {s};
		for each successor s' of s
			if s' was never visited by ARA* before then
				v(s') = g(s') = $\infty$;
			if g(s') > g(s) + c(s, s')
				g(s') = g(s) + c(s, s');
				if s' $\notin$ CLOSED
					insert/update s' in OPEN with key(s');
				else
					insert s' into INCONS;
\end{lstlisting}

 
\begin{lstlisting}[mathescape, label=lst-dinamicos-ara-key, caption=Algoritmo ARA* - função da chave ordenadora da fila de prioridades, float=htpb]
procedure key(s)
	return g(s) + $\epsilon$ * h(s);
\end{lstlisting}

\begin{lstlisting}[mathescape, label=lst-dinamicos-ara-main, caption=Algoritmo ARA* - função principal, float=htpb]
procedure Main()
	g($s_{goal}$) = v($s_{goal}$) = $\infty$; v($s_{start}$) = $\infty$;
	g($s_{start}$) = 0; OPEN = CLOSED = INCONS = $\emptyset$;
	insert $s_{start}$ into OPEN with key($s_{start}$);
	ComputePath();
	publish current $\epsilon$-suboptimal solution;
	while $\epsilon > 1$
		decrease $\epsilon$;
		Move states from INCONS into OPEN
		Update the priorities for all s $\in$ OPEN according to key(s);
		CLOSED = $\emptyset$;
		ComputePath();
		publish current $\epsilon$-suboptimal solution;
\end{lstlisting}

\section{Algoritmo AD*}
\label{sec-dinamicos-ad}

O algoritmo AD* também proposto em \citeonline{likhachev2008anytime}, está descrito nas listagens \ref{lst-dinamicos-ad-set}, \ref{lst-dinamicos-ad-computepath}, \ref{lst-dinamicos-ad-key} e \ref{lst-dinamicos-ad-main}.

\begin{lstlisting}[mathescape, label=lst-dinamicos-ad-set, caption=Algoritmo AD* - função para determinar o conjunto ao qual vértice pertencerá, float=htpb]
procedure UpdateSetMembership(s)
	if ($v(s) \neq g(s)$)
		if (s $\notin$ CLOSED) insert/update s in OPEN with key(s);
		else if (s $\notin$ INCONS) insert s in INCONS;
	else
		if (s $\in$ OPEN) remove s from OPEN;
		else if (s $\in$ INCONS) remove s from INCONS;
\end{lstlisting}

\begin{lstlisting}[mathescape, label=lst-dinamicos-ad-computepath, caption=Algoritmo AD* - função de cálculo de caminho, float=htpb]
procedure ComputePath()
	while(key($s_{goal}$) > $min_{s \in OPEN(key(s))}$ OR v($s_{goal}$) < g($s_{goal}$)) 
		remove s with smallest key(s) from OPEN;
		v(s) = g(s); CLOSED = CLOSED $\cup$ {s};
		for each successor s' of s
			if s' was never visited by ARA* before then
				v(s') = g(s') = $\infty$;bp(s') = null;
			if g(s') > g(s) + c(s, s')
				g(s') = g(s) + c(s, s');
				bp(s') = s;
				g(s') = g(bp(s')) + c(bp(s'),s'); UpdateSetMembership(s');
			else
				v(s) = $\infty$; UpdateSetMembership(s);
				for each successor s' of s
				if s' was never visited by ARA* before then
					v(s') = g(s') = $\infty$;bp(s') = null;
				if bp(s') = s
					bp(s') = $argmin_{s'' \in pred(s')}$ v(s'') + c(s'',s');
					g(s') = v(bp(s')) + c(bp(s'),s'); UpdateSetMembership(s');
\end{lstlisting}

\begin{lstlisting}[mathescape, label=lst-dinamicos-ad-key, caption=Algoritmo AD* - função da chave ordenadora da fila de prioridades, float=htpb]
procedure key(s)
	if (v(s) $\geq$ g(s))
		return [g(s) + $\epsilon$ * h(s); g(s)];
	else
		return [v(s) + h(s); v(s)];
\end{lstlisting}

\begin{lstlisting}[mathescape, label=lst-dinamicos-ad-main, caption=Algoritmo AD* - função principal, float=htpb]
procedure Main()
	g($s_{goal}$) = v($s_{goal}$) = $\infty$; v($s_{start}$) = $\infty$;bp($s_{goal}$) = bp($s_{start}$) = null;
	g($s_{start}$) = 0; OPEN = CLOSED = INCONS = $\emptyset$; $\epsilon = \epsilon_{0}$;
	insert $s_{start}$ into OPEN with key($s_{start}$);
	forever
		ComputePath();
		publish current $\epsilon$-suboptimal solution;
		if $\epsilon = 1$
			wait changes in edge costs;
		for all directed edges (u,v) with changed edge costs
			update the edge cost (u,v);
			if ( $v \neq s_{start}$ AND v was visited by AD* before)
				bp(v) = $argmin_{s'' \in pred(v)}$ v(s'') + c(s'',v);
				g(v) = v(bp(v)) + c(bp(v),v); UpdateSetMembership(v);
		if significant edge cost changes were observed
			increase $\epsilon$ or re-plan from scratch (i.e., re-excute Main function);
		else if $\epsilon > 1$
			decrease $\epsilon$;
		Move states from INCONS into OPEN
		Update the priorities for all s $\in$ OPEN according to key(s);
		CLOSED = $\emptyset$;
\end{lstlisting}